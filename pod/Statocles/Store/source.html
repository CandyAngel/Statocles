<!DOCTYPE html>
<html>
    <head>
        <link href="/statocles/theme/css/normalize.css" rel="stylesheet">
        <link href="/statocles/theme/css/skeleton.css" rel="stylesheet">
        <link href="/statocles/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Statocles</title>
        <meta content="Statocles 0.056" name="generator">
        <link href="http://fonts.googleapis.com/css?family=Forum" rel="stylesheet" type="text/css">
<style>
    h1, h2, h3, h4, h5, h6 {
        font-family: 'Forum', sans-serif;
        font-weight: bold;
    }

    #index-banner {
        font-family: 'Forum', sans-serif;
        height: 300px;
        position: relative;
        margin-bottom: 1em;
        border-bottom: 1px solid #777
    }
    #index-banner:before, #index-banner:after {
        width: 60px;
        height: 300px;
        content: url(http://preaction.me/statocles//theme/images/column.png);
    }
    #index-banner:before {
        position: absolute;
        top: 0;
        left: 0;
    }
    #index-banner:after {
        position: absolute;
        top: 0;
        right: 0;
    }

    #index-banner h1 {
        padding-top: 1em;
        text-transform: uppercase;
        font-size: 72px;
        text-align: center;
    }
    #index-banner h1 small {
        display: block;
        font-size: 24px;
    }

    #index-banner .latest-release {
        text-align: center;
    }

</style>
<link href="http://preaction.me/statocles/pod/Statocles/Store/source.html" rel="canonical">
<script>
    if ( location.href.indexOf( "http://preaction.me/statocles/" ) == -1 ) {
        location.href = "http://preaction.me/statocles/pod/Statocles/Store/source.html";
    }
</script>

    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/statocles/">Statocles</a>
                    <ul>
                        <li>
                            <a href="/statocles/blog">Blog</a>
                        </li>
                        <li>
                            <a href="/statocles/pod">Docs</a>
                        </li>
                        <li>
                            <a href="/statocles/gallery">Gallery</a>
                        </li>
                        <li>
                            <a href="http://github.com/preaction/Statocles">Code</a>
                        </li>
                        <li>
                            <a href="http://github.com/preaction/Statocles/issues">Bugs</a>
                        </li>
                        <li>
                            <a href="http://metacpan.org/pod/Statocles">CPAN</a>
                        </li>
                        <li>
                            <a href="https://chat.mibbit.com/?channel=%23statocles&amp;server=irc.perl.org">IRC</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            <a href="https://github.com/preaction/Statocles"><img alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" style="position: absolute; top: 0; right: 0; z-index: 1000; border: 0;"></a>

        </header>
        <div class="main container">
            <a class="button" href="/statocles/pod/Statocles/Store/">
    Back to documentation
</a>
<pre>package Statocles::Store;
# ABSTRACT: The source for data documents and files

use Statocles::Base &#39;Class&#39;;
use Scalar::Util qw( weaken blessed );
use Statocles::Document;
use YAML;
use File::Spec::Functions qw( splitdir );
use Module::Runtime qw( use_module );

my $DATETIME_FORMAT = &#39;%Y-%m-%d %H:%M:%S&#39;;
my $DATE_FORMAT = &#39;%Y-%m-%d&#39;;

# A hash of PATH =&gt; COUNT for all the open store paths. Stores are not allowed to
# discover the files or documents of other stores (unless the two stores have the same
# path)
my %FILE_STORES = ();

=attr path

The path to the directory containing the L&lt;documents|Statocles::Document&gt;.

=cut

has path =&gt; (
    is =&gt; &#39;ro&#39;,
    isa =&gt; AbsPath,
    coerce =&gt; AbsPath-&gt;coercion,
    required =&gt; 1,
);

=attr document_extensions

An array of file extensions that should be considered documents. Defaults to
&quot;markdown&quot; and &quot;md&quot;.

=cut

has document_extensions =&gt; (
    is =&gt; &#39;ro&#39;,
    isa =&gt; ArrayRef[Str],
    default =&gt; sub { [qw( markdown md )] },
    coerce =&gt; sub {
        my ( $ext ) = @_;
        if ( !ref $ext ) {
            return [ split /[, ]/, $ext ];
        }
        return $ext;
    },
);

=attr documents

All the L&lt;documents|Statocles::Document&gt; currently read by this store.

=method clear

    $store-&gt;clear;

Clear the cached documents in this Store.

=cut

has documents =&gt; (
    is =&gt; &#39;rw&#39;,
    isa =&gt; ArrayRef[InstanceOf[&#39;Statocles::Document&#39;]],
    lazy =&gt; 1,
    builder =&gt; &#39;read_documents&#39;,
    clearer =&gt; &#39;clear&#39;,
);

# Cache our realpath in case it disappears before we get demolished
has _realpath =&gt; (
    is =&gt; &#39;ro&#39;,
    isa =&gt; Path,
    lazy =&gt; 1,
    default =&gt; sub { $_[0]-&gt;path-&gt;realpath },
);

sub BUILD {
    my ( $self ) = @_;
    if ( !$self-&gt;path-&gt;exists ) {
        die sprintf &quot;Store path &#39;%s&#39; does not exist&quot;, $self-&gt;path-&gt;stringify;
    }
    elsif ( !$self-&gt;path-&gt;is_dir ) {
        die sprintf &quot;Store path &#39;%s&#39; is not a directory&quot;, $self-&gt;path-&gt;stringify;
    }

    $FILE_STORES{ $self-&gt;_realpath }++;
}

sub DEMOLISH {
    my ( $self, $in_global_destruction ) = @_;
    return if $in_global_destruction; # We&#39;re ending, we don&#39;t need to care anymore
    if ( --$FILE_STORES{ $self-&gt;_realpath } &lt;= 0 ) {
        delete $FILE_STORES{ $self-&gt;_realpath };
    }
}

=method read_documents

    my $docs = $store-&gt;read_documents;

Read the directory C&lt;path&gt; and create the L&lt;document
objects|Statocles::Document&gt; inside.  Returns an arrayref of document objects.

=cut

sub read_documents {
    my ( $self ) = @_;
    my $root_path = $self-&gt;path;
    my @docs;
    my $iter = $root_path-&gt;iterator( { recurse =&gt; 1, follow_symlinks =&gt; 1 } );
    while ( my $path = $iter-&gt;() ) {
        next unless $path-&gt;is_file;
        next unless $self-&gt;_is_owned_path( $path );
        next unless $self-&gt;is_document( $path );
        my $rel_path = rootdir-&gt;child( $path-&gt;relative( $root_path ) );
        push @docs, $self-&gt;read_document( $rel_path );
    }
    return \@docs;
}

sub _is_owned_path {
    my ( $self, $path ) = @_;
    my $self_path = $self-&gt;_realpath;
    $path = $path-&gt;realpath;
    my $dir = $path-&gt;parent;
    for my $store_path ( keys %FILE_STORES ) {
        # This is us!
        next if $store_path eq $self_path;
        # If our store is contained inside this store&#39;s path, we win
        next if $self_path =~ /^\Q$store_path/;
        return 0 if $path =~ /^\Q$store_path/;
    }
    return 1;
}

=method read_document

    my $doc = $store-&gt;read_document( $path )

Read a single L&lt;document|Statocles::Document&gt; in Markdown with optional YAML
frontmatter.

=cut

sub read_document {
    my ( $self, $path ) = @_;
    site-&gt;log-&gt;debug( &quot;Read document: &quot; . $path );
    my $full_path = $self-&gt;path-&gt;child( $path );
    my %doc = $self-&gt;parse_frontmatter( $full_path, $full_path-&gt;slurp_utf8 );
    my $class = $doc{class} ? use_module( delete $doc{class} ) : &#39;Statocles::Document&#39;;
    return $class-&gt;new( %doc, path =&gt; $path );
}

=method parse_frontmatter

    my %doc_attrs = $store-&gt;parse_frontmatter( $from, $content )

Parse a document with YAML frontmatter. $from is a string identifying where the
content comes from (a path or other identifier). $content is the content to
parse for frontmatter.

=cut

sub parse_frontmatter {
    my ( $self, $from, $content ) = @_;
    my $doc;

    my @lines = split /\n/, $content;
    if ( $lines[0] =~ /^---/ ) {
        shift @lines;

        # The next --- is the end of the YAML frontmatter
        my ( $i ) = grep { $lines[ $_ ] =~ /^---/ } 0..$#lines;

        # If we did not find the marker between YAML and Markdown
        if ( !defined $i ) {
            die &quot;Could not find end of front matter (---) in &#39;$from&#39;\n&quot;;
        }

        # Before the marker is YAML
        eval {
            $doc = YAML::Load( join &quot;\n&quot;, splice( @lines, 0, $i ), &quot;&quot; );
        };
        if ( $@ ) {
            die &quot;Error parsing YAML in &#39;$from&#39;\n$@&quot;;
        }

        # Remove the last &#39;---&#39; mark
        shift @lines;
    }

    $doc-&gt;{content} = join &quot;\n&quot;, @lines, &quot;&quot;;

    if ( exists $doc-&gt;{date} ) {

        my $dt;
        eval {
            $dt = Time::Piece-&gt;strptime( $doc-&gt;{date}, $DATETIME_FORMAT );
        };

        if ( $@ ) {
            eval {
                $dt = Time::Piece-&gt;strptime( $doc-&gt;{date}, $DATE_FORMAT );
            };

            if ( $@ ) {
                die sprintf &quot;Could not parse date &#39;%s&#39;. Does not match &#39;%s&#39; or &#39;%s&#39;&quot;,
                    $doc-&gt;{date},
                    $DATETIME_FORMAT,
                    $DATE_FORMAT,
                    ;
            }

        }

        $doc-&gt;{date} = $dt;
    }

    return %$doc;
}

=method write_document

    $store-&gt;write_document( $path, $doc );

Write a L&lt;document|Statocles::Document&gt; to the store at the given store path.

The document is written in Frontmatter format.

=cut

sub write_document {
    my ( $self, $path, $doc ) = @_;
    $path = Path-&gt;coercion-&gt;( $path ); # Allow stringified paths, $path =&gt; $doc
    if ( $path-&gt;is_absolute ) {
        die &quot;Cannot write document &#39;$path&#39;: Path must not be absolute&quot;;
    }
    site-&gt;log-&gt;debug( &quot;Write document: &quot; . $path );

    $doc = { %{ $doc } }; # Shallow copy for safety
    my $content = delete( $doc-&gt;{content} ) // &#39;&#39;;
    my $header = YAML::Dump( $self-&gt;_freeze_document( $doc ) );
    chomp $header;

    my $full_path = $self-&gt;path-&gt;child( $path );
    $full_path-&gt;touchpath-&gt;spew_utf8( join &quot;\n&quot;, $header, &#39;---&#39;, $content );

    if ( defined wantarray ) {
        warn &quot;Statocles::Store-&gt;write_document returning a value is deprecated and will be removed in v1.0. Use Statocles::Store-&gt;path to find the full path to the document.&quot;;
    }
    return $full_path;
}

sub _freeze_document {
    my ( $self, $doc ) = @_;
    delete $doc-&gt;{path}; # Path should not be in the document
    if ( exists $doc-&gt;{date} ) {
        $doc-&gt;{date} = $doc-&gt;{date}-&gt;strftime( $DATETIME_FORMAT );
    }
    if ( exists $doc-&gt;{links} ) {
        if ( !keys %{ $doc-&gt;{links} } ) {
            delete $doc-&gt;{links};
        }
    }
    return $doc;
}

=method is_document

    my $bool = $store-&gt;is_document( $path );

Returns true if the path looks like a document path (matches the L&lt;/document_extensions&gt;).

=cut

sub is_document {
    my ( $self, $path ) = @_;
    my $match = join &quot;|&quot;, @{ $self-&gt;document_extensions };
    return $path =~ /[.](?:$match)$/;
}

=method read_file

    my $content = $store-&gt;read_file( $path )

Read the file from the given C&lt;path&gt;.

=cut

sub read_file {
    my ( $self, $path ) = @_;
    site-&gt;log-&gt;debug( &quot;Read file: &quot; . $path );
    return $self-&gt;path-&gt;child( $path )-&gt;slurp_utf8;
}

=method has_file

    my $bool = $store-&gt;has_file( $path )

Returns true if a file exists with the given C&lt;path&gt;.

NOTE: This should not be used to check for directories, as not all stores have
directories.

=cut

sub has_file {
    my ( $self, $path ) = @_;
    return $self-&gt;path-&gt;child( $path )-&gt;is_file;
}

=method find_files

    my $iter = $store-&gt;find_files( %opt )
    while ( my $path = $iter-&gt;() ) {
        # ...
    }

Returns an iterator that, when called, produces a single path suitable to be passed
to L&lt;read_file&gt;.

Available options are:

    include_documents      - If true, will include files that look like documents.
                             Defaults to false.

=cut

sub find_files {
    my ( $self, %opt ) = @_;
    my $iter = $self-&gt;path-&gt;iterator({ recurse =&gt; 1 });
    return sub {
        my $path;
        while ( $path = $iter-&gt;() ) {
            next if $path-&gt;is_dir;
            next if !$self-&gt;_is_owned_path( $path );
            next if !$opt{include_documents} &amp;&amp; $self-&gt;is_document( $path );
            last;
        }
        return unless $path; # iterator exhausted
        return $path-&gt;relative( $self-&gt;path )-&gt;absolute( &#39;/&#39; );
    };
}

=method open_file

    my $fh = $store-&gt;open_file( $path )

Open the file with the given path. Returns a filehandle.

The filehandle opened is using raw bytes, not UTF-8 characters.

=cut

sub open_file {
    my ( $self, $path ) = @_;
    return $self-&gt;path-&gt;child( $path )-&gt;openr_raw;
}

=method write_file

    $store-&gt;write_file( $path, $content );

Write the given C&lt;content&gt; to the given C&lt;path&gt;. This is mostly used to write
out L&lt;page objects|Statocles::Page&gt;.

C&lt;content&gt; may be a simple string or a filehandle. If given a string, will
write the string using UTF-8 characters. If given a filehandle, will write out
the raw bytes read from it with no special encoding.

=cut

sub write_file {
    my ( $self, $path, $content ) = @_;
    site-&gt;log-&gt;debug( &quot;Write file: &quot; . $path );
    my $full_path = $self-&gt;path-&gt;child( $path );

    if ( ref $content eq &#39;GLOB&#39; ) {
        my $fh = $full_path-&gt;touchpath-&gt;openw_raw;
        while ( my $line = &lt;$content&gt; ) {
            $fh-&gt;print( $line );
        }
    }
    else {
        $full_path-&gt;touchpath-&gt;spew_utf8( $content );
    }

    return;
}

=method remove

    $store-&gt;remove( $path )

Remove the given path from the store. If the path is a directory, the entire
directory is removed.

=cut

sub remove {
    my ( $self, $path ) = @_;
    $self-&gt;path-&gt;child( $path )-&gt;remove_tree;
    return;
}

1;
__END__

=head1 DESCRIPTION

A Statocles::Store reads and writes L&lt;documents|Statocles::Document&gt; and
files (mostly L&lt;pages|Statocles::Page&gt;).

This class also handles the parsing and inflating of
L&lt;&quot;document objects&quot;|Statocles::Document&gt;.

=head2 Frontmatter Document Format

Documents are formatted with a YAML document on top, and Markdown content
on the bottom, like so:

    ---
    title: This is a title
    author: preaction
    ---
    # This is the markdown content
    
    This is a paragraph

</pre>

        </div>
        <footer>
            <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61295159-3', 'auto');
  ga('send', 'pageview');

</script>

            <div class="container tagline">
                <a href="http://preaction.me/statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>
    </body>
</html>
