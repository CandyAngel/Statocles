<!DOCTYPE html>
<html>
    <head>
        <link href="/Statocles/theme/css/normalize.css" rel="stylesheet">
        <link href="/Statocles/theme/css/skeleton.css" rel="stylesheet">
        <link href="/Statocles/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Statocles</title>
        <meta content="Statocles 0.055" name="generator">
        <link href="http://fonts.googleapis.com/css?family=Forum" rel="stylesheet" type="text/css">
<style>
    h1, h2, h3, h4, h5, h6 {
        font-family: 'Forum', sans-serif;
        font-weight: bold;
    }

    #index-banner {
        font-family: 'Forum', sans-serif;
        height: 300px;
        position: relative;
        margin-bottom: 1em;
        border-bottom: 1px solid #777
    }
    #index-banner:before, #index-banner:after {
        width: 60px;
        height: 300px;
        content: url(/Statocles/theme/images/column.png);
    }
    #index-banner:before {
        position: absolute;
        top: 0;
        left: 0;
    }
    #index-banner:after {
        position: absolute;
        top: 0;
        right: 0;
    }

    #index-banner h1 {
        padding-top: 1em;
        text-transform: uppercase;
        font-size: 72px;
        text-align: center;
    }
    #index-banner h1 small {
        display: block;
        font-size: 24px;
    }

    #index-banner .latest-release {
        text-align: center;
    }

</style>

    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/Statocles/">Statocles</a>
                    <ul>
                        <li>
                            <a href="/Statocles/blog">Blog</a>
                        </li>
                        <li>
                            <a href="/Statocles/pod">Docs</a>
                        </li>
                        <li>
                            <a href="/Statocles/gallery">Gallery</a>
                        </li>
                        <li>
                            <a href="http://github.com/preaction/Statocles">Code</a>
                        </li>
                        <li>
                            <a href="http://github.com/preaction/Statocles/issues">Bugs</a>
                        </li>
                        <li>
                            <a href="http://metacpan.org/pod/Statocles">CPAN</a>
                        </li>
                        <li>
                            <a href="https://chat.mibbit.com/?channel=%23statocles&amp;server=irc.perl.org">IRC</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            <a href="https://github.com/preaction/Statocles"><img alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" style="position: absolute; top: 0; right: 0; z-index: 1000; border: 0;"></a>

        </header>
        <div class="main container">
            <a class="button" href="/Statocles/pod/Statocles/App/Blog/">
    Back to documentation
</a>
<pre>package Statocles::App::Blog;
# ABSTRACT: A blog application

use Statocles::Base &#39;Class&#39;;
use Getopt::Long qw( GetOptionsFromArray );
use Statocles::Store;
use Statocles::Page::Document;
use Statocles::Page::List;
use Statocles::Util qw( run_editor );

with &#39;Statocles::App::Role::Store&#39;;

=attr store

The L&lt;store|Statocles::Store&gt; to read for documents.

=cut

=attr tag_text

A hash of tag and descriptions to introduce tags. Having a description is optional.

=cut

has tag_text =&gt; (
    is =&gt; &#39;ro&#39;,
    isa =&gt; HashRef,
    default =&gt; sub { {} },
);

=attr page_size

The number of posts to put in a page (the main page and the tag pages). Defaults
to 5.

=cut

has page_size =&gt; (
    is =&gt; &#39;ro&#39;,
    isa =&gt; Int,
    default =&gt; sub { 5 },
);

=attr index_tags

Filter the tags shown in the index page. An array of tags prefixed with either
a + or a -. By prefixing the tag with a &quot;-&quot;, it will be removed from the index,
unless a later tag prefixed with a &quot;+&quot; also matches.

By default, all tags are shown on the index page.

So, given a document with tags &quot;foo&quot;, and &quot;bar&quot;:

    index_tags =&gt; [ ];                  # document will be included
    index_tags =&gt; [ &#39;-foo&#39; ];           # document will not be included
    index_tags =&gt; [ &#39;-foo&#39;, &#39;+bar&#39; ];   # document will be included

=cut

has index_tags =&gt; (
    is =&gt; &#39;ro&#39;,
    isa =&gt; ArrayRef[Str],
    default =&gt; sub { [] },
);

# A cache of the last set of post pages we have
# XXX: We need to allow apps to have a &quot;clear&quot; the way that Store and Theme do
has _post_pages =&gt; (
    is =&gt; &#39;rw&#39;,
    isa =&gt; ArrayRef,
    predicate =&gt; &#39;_has_cached_post_pages&#39;,
);

=method command

    my $exitval = $app-&gt;command( $app_name, @args );

Run a command on this app. The app name is used to build the help, so
users get exactly what they need to run.

=cut

our $default_post = {
    tags =&gt; undef,
    content =&gt; &lt;&lt;&#39;ENDCONTENT&#39;,
Markdown content goes here.
ENDCONTENT
};

my $USAGE_INFO = &lt;&lt;&#39;ENDHELP&#39;;
Usage:
    $name help -- This help file
    $name post [--date YYYY-MM-DD] &lt;title&gt; -- Create a new blog post with the given title
ENDHELP

sub command {
    my ( $self, $name, @argv ) = @_;

    if ( !$argv[0] ) {
        say STDERR &quot;ERROR: Missing command&quot;;
        say STDERR eval &quot;qq{$USAGE_INFO}&quot;;
        return 1;
    }

    if ( $argv[0] eq &#39;help&#39; ) {
        say eval &quot;qq{$USAGE_INFO}&quot;;
    }
    elsif ( $argv[0] eq &#39;post&#39; ) {
        my %opt;
        GetOptionsFromArray( \@argv, \%opt,
            &#39;date:s&#39;,
        );

        my %doc = (
            %$default_post,
            title =&gt; join &quot; &quot;, @argv[1..$#argv],
        );

        # Read post content on STDIN
        if ( !-t *STDIN ) {
            my $content = do { local $/; &lt;STDIN&gt; };
            %doc = (
                %doc,
                $self-&gt;store-&gt;parse_frontmatter( &quot;&lt;STDIN&gt;&quot;, $content ),
            );

            # Re-open STDIN as the TTY so that the editor (vim) can use it
            # XXX Is this also a problem on Windows?
            if ( -e &#39;/dev/tty&#39; ) {
                close STDIN;
                open STDIN, &#39;/dev/tty&#39;;
            }
        }

        if ( !$ENV{EDITOR} &amp;&amp; !$doc{title} ) {
            say STDERR &lt;&lt;&quot;ENDHELP&quot;;
Title is required when \$EDITOR is not set.

Usage: $name post &lt;title&gt;
ENDHELP
            return 1;
        }

        my ( $year, $mon, $day );
        if ( $opt{ date } ) {
            ( $year, $mon, $day ) = split /-/, $opt{date};
        }
        else {
            ( undef, undef, undef, $day, $mon, $year ) = localtime;
            $year += 1900;
            $mon += 1;
        }

        my @date_parts = (
            sprintf( &#39;%04i&#39;, $year ),
            sprintf( &#39;%02i&#39;, $mon ),
            sprintf( &#39;%02i&#39;, $day ),
        );

        my $slug = $self-&gt;make_slug( $doc{title} || &quot;new post&quot; );
        my $path = Path::Tiny-&gt;new( @date_parts, $slug, &quot;index.markdown&quot; );
        $self-&gt;store-&gt;write_document( $path =&gt; \%doc );
        my $full_path = $self-&gt;store-&gt;path-&gt;child( $path );

        if ( run_editor( $full_path ) ) {
            my $old_title = $doc{title};
            %doc = %{ $self-&gt;store-&gt;read_document( $path ) };
            if ( $doc{title} ne $old_title ) {
                $self-&gt;store-&gt;path-&gt;child( $path-&gt;parent )-&gt;remove_tree;
                $slug = $self-&gt;make_slug( $doc{title} || &quot;new post&quot; );
                $path = Path::Tiny-&gt;new( @date_parts, $slug, &quot;index.markdown&quot; );
                $self-&gt;store-&gt;write_document( $path =&gt; \%doc );
                $full_path = $self-&gt;store-&gt;path-&gt;child( $path );
            }
        }

        say &quot;New post at: $full_path&quot;;

    }
    else {
        say STDERR qq{ERROR: Unknown command &quot;$argv[0]&quot;};
        say STDERR eval &quot;qq{$USAGE_INFO}&quot;;
        return 1;
    }

    return 0;
}

=method make_slug

    my $slug = $app-&gt;make_slug( $title );

Given a post title, remove special characters to create a slug.

=cut

sub make_slug {
    my ( $self, $slug ) = @_;
    $slug =~ s/[\W]+/-/g;
    return lc $slug;
}

=method index

    my @pages = $app-&gt;index( \@post_pages );

Build the index page (a L&lt;list page|Statocles::Page::List&gt;) and all related
feed pages out of the given array reference of post pages.

=cut

my %FEEDS = (
    rss =&gt; {
        text =&gt; &#39;RSS&#39;,
        template =&gt; &#39;index.rss&#39;,
    },
    atom =&gt; {
        text =&gt; &#39;Atom&#39;,
        template =&gt; &#39;index.atom&#39;,
    },
);

sub index {
    my ( $self, $all_post_pages ) = @_;

    # Filter the index_tags
    my @index_post_pages;
    PAGE: for my $page ( @$all_post_pages ) {
        my $add = 1;
        for my $tag_spec ( @{ $self-&gt;index_tags } ) {
            my $flag = substr $tag_spec, 0, 1;
            my $tag = substr $tag_spec, 1;
            if ( grep { $_ eq $tag } @{ $page-&gt;document-&gt;tags } ) {
                $add = $flag eq &#39;-&#39; ? 0 : 1;
            }
        }
        push @index_post_pages, $page if $add;
    }

    my @pages = Statocles::Page::List-&gt;paginate(
        after =&gt; $self-&gt;page_size,
        path =&gt; $self-&gt;url_root . &#39;/page/%i/index.html&#39;,
        index =&gt; $self-&gt;url_root . &#39;/index.html&#39;,
        # Sorting by path just happens to also sort by date
        pages =&gt; [ sort { $b-&gt;path cmp $a-&gt;path } @index_post_pages ],
        app =&gt; $self,
        template =&gt; $self-&gt;site-&gt;theme-&gt;template( blog =&gt; &#39;index.html&#39; ),
        layout =&gt; $self-&gt;site-&gt;theme-&gt;template( site =&gt; &#39;layout.html&#39; ),
    );

    return unless @pages; # Only build feeds if we have pages

    my $index = $pages[0];
    my @feed_pages;
    my @feed_links;
    for my $feed ( sort keys %FEEDS ) {
        my $page = Statocles::Page::List-&gt;new(
            app =&gt; $self,
            pages =&gt; $index-&gt;pages,
            path =&gt; $self-&gt;url_root . &#39;/index.&#39; . $feed,
            template =&gt; $self-&gt;site-&gt;theme-&gt;template( blog =&gt; $FEEDS{$feed}{template} ),
            links =&gt; {
                alternate =&gt; [
                    $self-&gt;link(
                        href =&gt; $index-&gt;path,
                        title =&gt; &#39;index&#39;,
                        type =&gt; $index-&gt;type,
                    ),
                ],
            },
        );

        push @feed_pages, $page;
        push @feed_links, $self-&gt;link(
            text =&gt; $FEEDS{ $feed }{ text },
            href =&gt; $page-&gt;path-&gt;stringify,
            type =&gt; $page-&gt;type,
        );
    }

    # Add the feeds to all the pages
    for my $page ( @pages ) {
        $page-&gt;_links-&gt;{feed} = \@feed_links;
    }

    return ( @pages, @feed_pages );
}

=method tag_pages

    my @pages = $app-&gt;tag_pages( \%tag_pages );

Get L&lt;pages|Statocles::Page&gt; for the tags in the given blog post documents
(build from L&lt;the post_pages method|/post_pages&gt;, including relevant feed
pages.

=cut

sub tag_pages {
    my ( $self, $tagged_docs ) = @_;

    my @pages;
    for my $tag ( keys %$tagged_docs ) {
        my @tag_pages = Statocles::Page::List-&gt;paginate(
            after =&gt; $self-&gt;page_size,
            path =&gt; join( &quot;/&quot;, $self-&gt;url_root, &#39;tag&#39;, $self-&gt;_tag_url( $tag ), &#39;page/%i/index.html&#39; ),
            index =&gt; join( &quot;/&quot;, $self-&gt;url_root, &#39;tag&#39;, $self-&gt;_tag_url( $tag ), &#39;index.html&#39; ),
            # Sorting by path just happens to also sort by date
            pages =&gt; [ sort { $b-&gt;path cmp $a-&gt;path } @{ $tagged_docs-&gt;{ $tag } } ],
            app =&gt; $self,
            template =&gt; $self-&gt;site-&gt;theme-&gt;template( blog =&gt; &#39;index.html&#39; ),
            layout =&gt; $self-&gt;site-&gt;theme-&gt;template( site =&gt; &#39;layout.html&#39; ),
            data =&gt; {
                tag_text =&gt; $self-&gt;tag_text-&gt;{ $tag },
            },
        );

        my $index = $tag_pages[0];
        my @feed_pages;
        my @feed_links;
        for my $feed ( sort keys %FEEDS ) {
            my $tag_file = $self-&gt;_tag_url( $tag ) . &#39;.&#39; . $feed;

            my $page = Statocles::Page::List-&gt;new(
                app =&gt; $self,
                pages =&gt; $index-&gt;pages,
                path =&gt; join( &quot;/&quot;, $self-&gt;url_root, &#39;tag&#39;, $tag_file ),
                template =&gt; $self-&gt;site-&gt;theme-&gt;template( blog =&gt; $FEEDS{$feed}{template} ),
                links =&gt; {
                    alternate =&gt; [
                        $self-&gt;link(
                            href =&gt; $index-&gt;path,
                            title =&gt; $tag,
                            type =&gt; $index-&gt;type,
                        ),
                    ],
                },
            );

            push @feed_pages, $page;
            push @feed_links, $self-&gt;link(
                text =&gt; $FEEDS{ $feed }{ text },
                href =&gt; $page-&gt;path-&gt;stringify,
                type =&gt; $page-&gt;type,
            );
        }

        # Add the feeds to all the pages
        for my $page ( @tag_pages ) {
            $page-&gt;_links-&gt;{feed} = \@feed_links;
        }

        push @pages, @tag_pages, @feed_pages;
    }

    return @pages;
}

=method pages

    my @pages = $app-&gt;pages( %options );

Get all the L&lt;pages|Statocles::Page&gt; for this application. Available options
are:

=over 4

=item date

The date to build for. Only posts on or before this date will be built.
Defaults to the current date.

=back

=cut

# sub pages
around pages =&gt; sub {
    my ( $orig, $self, %opt ) = @_;
    $opt{date} ||= Time::Piece-&gt;new-&gt;ymd;
    my $root = $self-&gt;url_root;
    my $is_dated_path = qr{^$root/?(\d{4})/(\d{2})/(\d{2})/};
    my @parent_pages = $self-&gt;$orig( %opt );
    my @pages =
        map { $_-&gt;[0] }
        # Sort by date
        sort { $b-&gt;[1] cmp $a-&gt;[1] }
        # Only pages today or before
        grep { $_-&gt;[1] le $opt{date} }
        # Create the page&#39;s date
        map { [ $_, join &quot;-&quot;, $_-&gt;path =~ $is_dated_path ] }
        # Only dated pages
        grep { $_-&gt;path =~ $is_dated_path }
        #$self-&gt;$orig( %opt );
        @parent_pages;
    my @post_pages;
    my %tag_pages;

    for my $page ( @pages ) {

        if ( $page-&gt;isa( &#39;Statocles::Page::Document&#39; ) ) {

            if ( $page-&gt;path =~ m{$is_dated_path [^/]+ (?:/index)? [.]html$}x ) {
                my $date = join &quot;-&quot;, $1, $2, $3;

                push @post_pages, $page;

                my $doc = $page-&gt;document;
                $page-&gt;date( $doc-&gt;has_date ? $doc-&gt;date : Time::Piece-&gt;strptime( $date, &#39;%Y-%m-%d&#39; ) );

                my @tags;
                for my $tag ( @{ $doc-&gt;tags } ) {
                    push @{ $tag_pages{ $tag } }, $page;
                    push @tags, $self-&gt;link(
                        text =&gt; $tag,
                        href =&gt; join( &quot;/&quot;, &#39;tag&#39;, $self-&gt;_tag_url( $tag ), &#39;&#39; ),
                    );
                }
                $page-&gt;tags( \@tags );

                $page-&gt;template( $self-&gt;site-&gt;theme-&gt;template( blog =&gt; &#39;post.html&#39; ) );
            }
        }
    }

    # Cache the post pages for this build
    # XXX: This needs to be handled more intelligently with proper dependencies
    $self-&gt;_post_pages( \@post_pages );

    my @all_pages = ( $self-&gt;index( \@post_pages ), $self-&gt;tag_pages( \%tag_pages ), @pages );
    return @all_pages;
};

=method tags

    my @links = $app-&gt;tags;

Get a set of L&lt;link objects|Statocles::Link&gt; suitable for creating a list of
tag links. The common attributes are:

    text =&gt; &#39;The tag text&#39;
    href =&gt; &#39;The URL to the tag page&#39;

=cut

sub tags {
    my ( $self ) = @_;
    my %tags;
    my @pages = @{ $self-&gt;_post_pages || [] };
    for my $page ( @pages ) {
        for my $tag ( @{ $page-&gt;document-&gt;tags } ) {
            $tags{ $tag }++;
        }
    }
    return map {; $self-&gt;link( text =&gt; $_, href =&gt; join( &quot;/&quot;, &#39;tag&#39;, $self-&gt;_tag_url( $_ ), &#39;&#39; ) ) }
        sort keys %tags;
}

sub _tag_url {
    my ( $self, $tag ) = @_;
    $tag =~ s/\s+/-/g;
    return $tag;
}

=method recent_posts

    my @pages = $app-&gt;recent_posts( $count, %filter );

Get the last $count recent posts for this blog. Useful for templates and site
index pages.

%filter is an optional set of filters to apply to only show recent posts
matching the given criteria. The following filters are available:

=over 4

=item tags

(string) Only show posts with the given tag

=back

=cut

sub recent_posts {
    my ( $self, $count, %filter ) = @_;

    my $root = $self-&gt;url_root;
    my @pages = $self-&gt;_has_cached_post_pages ? @{ $self-&gt;_post_pages } : $self-&gt;pages;
    my @found_pages;
    PAGE: for my $page ( @pages ) {
        next PAGE unless $page-&gt;path =~ qr{^$root/?(\d{4})/(\d{2})/(\d{2})/[^/]+(?:/index)?[.]html$};

        QUERY: for my $attr ( keys %filter ) {
            my $value = $filter{ $attr };
            if ( $attr eq &#39;tags&#39; ) {
                next PAGE unless grep { $_ eq $value } @{ $page-&gt;document-&gt;tags };
            }
        }

        push @found_pages, $page;
        last if @found_pages &gt;= $count;
    }

    return @found_pages;
}

=method page_url

    my $url = $app-&gt;page_url( $page )

Return the absolute URL to this L&lt;page object|Statocles::Page&gt;, removing the
&quot;/index.html&quot; if necessary.

=cut

# XXX This is TERRIBLE. We need to do this better. Perhaps a &quot;url()&quot; helper in the
# template? And a full_url() helper? Or perhaps the template knows whether it should
# use absolute (/whatever) or full (http://www.example.com/whatever) URLs?

sub page_url {
    my ( $self, $page ) = @_;
    my $url = &quot;&quot;.$page-&gt;path;
    $url =~ s{/index[.]html$}{/};
    return $url;
}

1;
__END__

=head1 DESCRIPTION

This is a simple blog application for Statocles.

=head2 FEATURES

=over

=item *

Content dividers. By dividing your main content with &quot;---&quot;, you create
sections. Only the first section will show up on the index page or in RSS
feeds.

=item *

RSS and Atom syndication feeds.

=item *

Tags to organize blog posts. Tags have their own custom feeds so users can
subscribe to only those posts they care about.

=item *

Cross-post links to redirect users to a syndicated blog. Useful when you
participate in many blogs and want to drive traffic to them.

=item *

Post-dated blog posts to appear automatically when the date is passed. If a
blog post is set in the future, it will not be added to the site when running
C&lt;build&gt; or C&lt;deploy&gt;.

In order to ensure that post-dated blogs get added, you may want to run
C&lt;deploy&gt; in a nightly cron job.

=back

=head1 COMMANDS

=head2 post

    post [--date &lt;date&gt;] &lt;title&gt;

Create a new blog post, optionally setting an initial C&lt;title&gt;. The post will be
created in a directory according to the current date.

Initial post content can be read from C&lt;STDIN&gt;. This lets you write other programs
to generate content for blog posts (for example, to help automate release blog posts).

=head1 THEME

=over

=item blog =&gt; index

The index page template. Gets the following template variables:

=over

=item site

The L&lt;Statocles::Site&gt; object.

=item pages

An array reference containing all the blog post pages. Each page is a hash reference with the following keys:

=over

=item content

The post content

=item title

The post title

=item author

The post author

=back

=item blog =&gt; post

The main post page template. Gets the following template variables:

=over

=item site

The L&lt;Statocles::Site&gt; object

=item content

The post content

=item title

The post title

=item author

The post author

=back

=back

=back

=head1 SEE ALSO

=over 4

=item L&lt;Statocles::App&gt;

=back

</pre>

        </div>
        <footer>
            <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61295159-3', 'auto');
  ga('send', 'pageview');

</script>

            <div class="container tagline">
                <a href="http://preaction.github.io/Statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>
    </body>
</html>
